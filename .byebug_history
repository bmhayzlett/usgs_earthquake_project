c
'hello, my name is brian. nice ot meent'[0..20]
data.length
data
c
exit
c
exit
c
regions
c
regions
c
regions
c
regions
exit
c
regions
c
regions
c
regions
c
regions
c
regions.length
regions
c
array[0..3]
array = Array.new(10,'hello')
regions.sort_by { |region| region.total_magnitude }
regions.sort_by { |region| region.num_earthquakes }
regions
c
earthquakes.length
c
regions
c
data['features'].length
regions
c
regions
c
regions
c
10**8.5
10**0.9
Math.log10(0.9)
Math.log10(total)
Math.log(10**8.23)
Math.log(total)
log(total)
total = 10** 8.23 + 10**0.5 + 10**4
10**8.23
10**0.5
10**.5
Math.log(0.5)
Math.log(.5)
Math.log(1)
@total_magnitude
@total_magnitudes
@magnitude
magnitude
c
regions
c
regions
exit
c
regions
c
matching_region
matching_region.add_earthquake
matching_region
c
regions
c
args
c
regions
c
regions
n
@num_earthquakes
n
args
c
regions
c
regions
c
x
regions
c
earthquake['properties']['mag']
earthquake
regions.find { |region| region.name == sub_region}
regions
c
sub_region = PythonInterface.query_flinn_engdahl(lat: lat, long: long)
sub_region
sub_region = _
PythonInterface.query_flinn_engdahl(lat: lat, long: long)
long
lat
c
Date.today
c
earthquake['geometry']['coordinates'][0]
earthquake['geometry']['coordinates']
earthquake['geometry']
earthquake
c
Date.today
c
earthquakes
c
data['features'].length
data['features'][0]
data[0]
c
url
res.body
JSON.parse(res.body)
c
data[0]
data = url_string
data = fetch_data(url_string)
c
n
@params
n
start_date
n
num_days
c
n
Date.today
c
data['features'].length
data['features'][0]
c
'hello, my name is'.upcase
@params
url_string
c
url_string
c
url_string
c
url_string
c
url_string
c
url_string
c
url_string
c
a.to_s
a = :a
@params
c
today - 1
today = Date.today
Date.today.strftime('%Y-%m-%d')
Date.today
today
@params
num_days = @params.delete(:days)
@params
exit
string[-1]
string.chop!
string
string.chop
string
string.chomp
string = 'hello'
@params
@url
c
@params
@url
c
@params
@url
c
@params
@url
c
n
arg
args
arg
exit
args
args.options
@params
@url
c
JSON.parse(res2.body)['features'][0]
JSON.parse(res2.body, :quirks_mode => true)['features'][0]
JSON.parse(res2.body, :quirks_mode => true)['type']
JSON.parse(res2.body, :quirks_mode => true)[:type]
JSON.parse(res2.body, :quirks_mode => true).type
JSON.parse(res2.body, :quirks_mode => true)
JSON.parse(res2.body, :quirks_mode => true)[0]
res2.body
res2
res2 = Net::HTTP.get_response(uri)
res
res.code
res.status
res
c
data.body
data
exit
hash.a
hash = {:a =>'c',:b =>'d'}
hash.a
hash = {'a'=>'c','b'=>'d'}
args.options
args
c
args
@params
@url
args
@params
c
!!args.options[:days]
args.options[:days]
args.options.days
args.options
args
exit
@options
c
@options
@options.merge(entry_type)
entry_type
@options
c
@options
entry_type
c
@options
c
@options
c
entry_type
c
entry_type
c
